{"version":3,"sources":["R.simplify.js"],"names":["EPSILON","TOLERANCE","Fitter","fit","path","error","commands","points","_commands","forEach","cmd","c","push","cc","p","length","fitCubic","sub","normalize","first","last","tan1","tan2","pt1","pt2","dist","mag","addCurve","add","mulSelf","uPrime","chordLengthParameterize","maxError","Math","max","split","parametersInOrder","i","curve","generateBezier","findMaxError","index","reparameterize","V1","V2","tanCenter","div","mul","x","y","epsilon","C","X","l","u","t","b","b0","b1","b2","b3","a1","a2","tmp","dot","detC0C1","alpha1","alpha2","abs","detC0X","detXC1","c0","c1","segLength","eps","handle1","handle2","line","findRoot","point","curve1","curve2","pt","evaluate","diff","df","degree","slice","j","m","floor","maxDist","P","v","module","exports","simplify"],"mappings":";;;;;;AAAA,IAAIA,UAAU,KAAd;AACA,IAAIC,YAAY,IAAhB;;AAEA,IAAIC,SAAS;AACTC,SAAK,aAAUC,IAAV,EAAgBC,KAAhB,EAAuB;AACxB,aAAKC,QAAL,GAAgB,EAAhB;AACA,aAAKD,KAAL,GAAaA,SAAS,EAAtB;;AAEA,YAAIE,SAAS,KAAKA,MAAL,GAAc,EAA3B;AACAH,aAAKI,SAAL,CAAeC,OAAf,CAAwB,UAAUC,GAAV,EAAe;AACnC,gBAAIC,IAAID,IAAI,CAAJ,CAAR;;AAEA,gBAAIC,MAAM,GAAV,EAAe;AACXJ,uBAAOK,IAAP,CAAaC,GAAGC,CAAH,CAAKJ,IAAI,CAAJ,CAAL,EAAaA,IAAI,CAAJ,CAAb,CAAb;AACH,aAFD,MAGK,IAAGC,MAAM,GAAT,EAAc;AACfJ,uBAAOK,IAAP,CAAaC,GAAGC,CAAH,CAAKJ,IAAI,CAAJ,CAAL,EAAaA,IAAI,CAAJ,CAAb,CAAb;AACH;AACJ,SATD;;AAYA,YAAIK,SAASR,OAAOQ,MAApB;;AAEA,YAAIA,SAAS,CAAb,EAAgB;AACZ,iBAAKC,QAAL,CAAc,CAAd,EAAiBD,SAAS,CAA1B;AACI;AACAR,mBAAO,CAAP,EAAUU,GAAV,CAAcV,OAAO,CAAP,CAAd,EAAyBW,SAAzB,EAFJ;AAGI;AACAX,mBAAOQ,SAAS,CAAhB,EAAmBE,GAAnB,CAAuBV,OAAOQ,SAAS,CAAhB,CAAvB,EAA2CG,SAA3C,EAJJ;AAKH;;AAED,eAAO,KAAKZ,QAAZ;AACH,KA7BQ;;AA+BT;AACAU,cAAU,kBAAUG,KAAV,EAAiBC,IAAjB,EAAuBC,IAAvB,EAA6BC,IAA7B,EAAmC;AACzC;AACA,YAAIF,OAAOD,KAAP,KAAiB,CAArB,EAAwB;AACpB,gBAAII,MAAM,KAAKhB,MAAL,CAAYY,KAAZ,CAAV;AAAA,gBACIK,MAAM,KAAKjB,MAAL,CAAYa,IAAZ,CADV;AAAA,gBAEIK,OAAOF,IAAIN,GAAJ,CAAQO,GAAR,EAAaE,GAAb,KAAqB,CAFhC;AAGA,iBAAKC,QAAL,CAAc,CAACJ,GAAD,EAAMA,IAAIK,GAAJ,CAAQP,KAAKH,SAAL,GAAiBW,OAAjB,CAAyBJ,IAAzB,CAAR,CAAN,EACND,IAAII,GAAJ,CAAQN,KAAKJ,SAAL,GAAiBW,OAAjB,CAAyBJ,IAAzB,CAAR,CADM,EACmCD,GADnC,CAAd;AAEA;AACH;AACD;AACA,YAAIM,SAAS,KAAKC,uBAAL,CAA6BZ,KAA7B,EAAoCC,IAApC,CAAb;AAAA,YACIY,WAAWC,KAAKC,GAAL,CAAS,KAAK7B,KAAd,EAAqB,KAAKA,KAAL,GAAa,KAAKA,KAAvC,CADf;AAAA,YAEI8B,KAFJ;AAAA,YAGIC,oBAAoB,IAHxB;AAIA;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,KAAK,CAArB,EAAwBA,GAAxB,EAA6B;AACzB,gBAAIC,QAAQ,KAAKC,cAAL,CAAoBpB,KAApB,EAA2BC,IAA3B,EAAiCU,MAAjC,EAAyCT,IAAzC,EAA+CC,IAA/C,CAAZ;AACA;AACA,gBAAIY,MAAM,KAAKM,YAAL,CAAkBrB,KAAlB,EAAyBC,IAAzB,EAA+BkB,KAA/B,EAAsCR,MAAtC,CAAV;AACA,gBAAII,IAAI7B,KAAJ,GAAY,KAAKA,KAAjB,IAA0B+B,iBAA9B,EAAiD;AAC7C,qBAAKT,QAAL,CAAcW,KAAd;AACA;AACH;AACDH,oBAAQD,IAAIO,KAAZ;AACA;AACA,gBAAIP,IAAI7B,KAAJ,IAAa2B,QAAjB,EACI;AACJI,gCAAoB,KAAKM,cAAL,CAAoBvB,KAApB,EAA2BC,IAA3B,EAAiCU,MAAjC,EAAyCQ,KAAzC,CAApB;AACAN,uBAAWE,IAAI7B,KAAf;AACH;AACD;AACA,YAAIsC,KAAK,KAAKpC,MAAL,CAAY4B,QAAQ,CAApB,EAAuBlB,GAAvB,CAA2B,KAAKV,MAAL,CAAY4B,KAAZ,CAA3B,CAAT;AAAA,YACIS,KAAK,KAAKrC,MAAL,CAAY4B,KAAZ,EAAmBlB,GAAnB,CAAuB,KAAKV,MAAL,CAAY4B,QAAQ,CAApB,CAAvB,CADT;AAAA,YAEIU,YAAYF,GAAGf,GAAH,CAAOgB,EAAP,EAAWE,GAAX,CAAe,CAAf,EAAkB5B,SAAlB,EAFhB;AAGA,aAAKF,QAAL,CAAcG,KAAd,EAAqBgB,KAArB,EAA4Bd,IAA5B,EAAkCwB,SAAlC;AACA,aAAK7B,QAAL,CAAcmB,KAAd,EAAqBf,IAArB,EAA2ByB,UAAUE,GAAV,CAAc,CAAC,CAAf,CAA3B,EAA8CzB,IAA9C;AACH,KArEQ;;AAuETK,cAAU,kBAASW,KAAT,EAAgB;AACtB,YAAI,KAAKhC,QAAL,CAAcS,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,iBAAKT,QAAL,CAAcM,IAAd,CAAmB,CAAC,GAAD,EAAM0B,MAAM,CAAN,EAASU,CAAf,EAAkBV,MAAM,CAAN,EAASW,CAA3B,CAAnB;AACH,SAFD,MAGK;AACD,gBAAIvC,MAAM,KAAKJ,QAAL,CAAc,KAAKA,QAAL,CAAcS,MAAd,GAAuB,CAArC,CAAV;AACAL,gBAAI,CAAJ,IAAS4B,MAAM,CAAN,EAASU,CAAlB;AACAtC,gBAAI,CAAJ,IAAS4B,MAAM,CAAN,EAASW,CAAlB;AACH;;AAED,aAAK3C,QAAL,CAAcM,IAAd,CAAmB,CAAC,GAAD,EAAM0B,MAAM,CAAN,EAASU,CAAf,EAAkBV,MAAM,CAAN,EAASW,CAA3B,EAA8BX,MAAM,CAAN,EAASU,CAAvC,EAA0CV,MAAM,CAAN,EAASW,CAAnD,EAAsDX,MAAM,CAAN,EAASU,CAA/D,EAAkEV,MAAM,CAAN,EAASW,CAA3E,CAAnB;AACH,KAlFQ;;AAoFT;AACAV,oBAAgB,wBAASpB,KAAT,EAAgBC,IAAhB,EAAsBU,MAAtB,EAA8BT,IAA9B,EAAoCC,IAApC,EAA0C;AACtD,YAAI4B,UAAU,MAAMlD,OAApB;AAAA,YACIuB,MAAM,KAAKhB,MAAL,CAAYY,KAAZ,CADV;AAAA,YAEIK,MAAM,KAAKjB,MAAL,CAAYa,IAAZ,CAFV;;AAGI;AACA+B,YAAI,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,EAAS,CAAC,CAAD,EAAI,CAAJ,CAAT,CAJR;AAAA,YAKIC,IAAI,CAAC,CAAD,EAAI,CAAJ,CALR;;AAOA,aAAK,IAAIf,IAAI,CAAR,EAAWgB,IAAIjC,OAAOD,KAAP,GAAe,CAAnC,EAAsCkB,IAAIgB,CAA1C,EAA6ChB,GAA7C,EAAkD;AAC9C,gBAAIiB,IAAIxB,OAAOO,CAAP,CAAR;AAAA,gBACIkB,IAAI,IAAID,CADZ;AAAA,gBAEIE,IAAI,IAAIF,CAAJ,GAAQC,CAFhB;AAAA,gBAGIE,KAAKF,IAAIA,CAAJ,GAAQA,CAHjB;AAAA,gBAIIG,KAAKF,IAAID,CAJb;AAAA,gBAKII,KAAKH,IAAIF,CALb;AAAA,gBAMIM,KAAKN,IAAIA,CAAJ,GAAQA,CANjB;AAAA,gBAOIO,KAAKxC,KAAKH,SAAL,GAAiBW,OAAjB,CAAyB6B,EAAzB,CAPT;AAAA,gBAQII,KAAKxC,KAAKJ,SAAL,GAAiBW,OAAjB,CAAyB8B,EAAzB,CART;AAAA,gBASII,MAAM,KAAKxD,MAAL,CAAYY,QAAQkB,CAApB,EACDpB,GADC,CACGM,IAAIwB,GAAJ,CAAQU,KAAKC,EAAb,CADH,EAEDzC,GAFC,CAEGO,IAAIuB,GAAJ,CAAQY,KAAKC,EAAb,CAFH,CATV;AAYAT,cAAE,CAAF,EAAK,CAAL,KAAWU,GAAGG,GAAH,CAAOH,EAAP,CAAX;AACAV,cAAE,CAAF,EAAK,CAAL,KAAWU,GAAGG,GAAH,CAAOF,EAAP,CAAX;AACA;AACAX,cAAE,CAAF,EAAK,CAAL,IAAUA,EAAE,CAAF,EAAK,CAAL,CAAV;AACAA,cAAE,CAAF,EAAK,CAAL,KAAWW,GAAGE,GAAH,CAAOF,EAAP,CAAX;AACAV,cAAE,CAAF,KAAQS,GAAGG,GAAH,CAAOD,GAAP,CAAR;AACAX,cAAE,CAAF,KAAQU,GAAGE,GAAH,CAAOD,GAAP,CAAR;AACH;;AAED;AACA,YAAIE,UAAUd,EAAE,CAAF,EAAK,CAAL,IAAUA,EAAE,CAAF,EAAK,CAAL,CAAV,GAAoBA,EAAE,CAAF,EAAK,CAAL,IAAUA,EAAE,CAAF,EAAK,CAAL,CAA5C;AAAA,YACIe,MADJ;AAAA,YACYC,MADZ;AAEA,YAAIlC,KAAKmC,GAAL,CAASH,OAAT,IAAoBf,OAAxB,EAAiC;AAC7B;AACA,gBAAImB,SAAUlB,EAAE,CAAF,EAAK,CAAL,IAAUC,EAAE,CAAF,CAAV,GAAoBD,EAAE,CAAF,EAAK,CAAL,IAAUC,EAAE,CAAF,CAA5C;AAAA,gBACIkB,SAAUlB,EAAE,CAAF,IAAUD,EAAE,CAAF,EAAK,CAAL,CAAV,GAAoBC,EAAE,CAAF,IAAUD,EAAE,CAAF,EAAK,CAAL,CAD5C;AAEA;AACAe,qBAASI,SAASL,OAAlB;AACAE,qBAASE,SAASJ,OAAlB;AACH,SAPD,MAOO;AACH;AACA,gBAAIM,KAAKpB,EAAE,CAAF,EAAK,CAAL,IAAUA,EAAE,CAAF,EAAK,CAAL,CAAnB;AAAA,gBACIqB,KAAKrB,EAAE,CAAF,EAAK,CAAL,IAAUA,EAAE,CAAF,EAAK,CAAL,CADnB;AAEA,gBAAIlB,KAAKmC,GAAL,CAASG,EAAT,IAAerB,OAAnB,EAA4B;AACxBgB,yBAASC,SAASf,EAAE,CAAF,IAAOmB,EAAzB;AACH,aAFD,MAEO,IAAItC,KAAKmC,GAAL,CAASI,EAAT,IAAetB,OAAnB,EAA4B;AAC/BgB,yBAASC,SAASf,EAAE,CAAF,IAAOoB,EAAzB;AACH,aAFM,MAEA;AACH;AACAN,yBAASC,SAAS,CAAlB;AACH;AACJ;;AAED;AACA;AACA;AACA,YAAIM,YAAYjD,IAAIP,GAAJ,CAAQM,GAAR,EAAaG,GAAb,EAAhB;AAAA,YACIgD,MAAMxB,UAAUuB,SADpB;AAAA,YAEIE,OAFJ;AAAA,YAGIC,OAHJ;AAIA,YAAIV,SAASQ,GAAT,IAAgBP,SAASO,GAA7B,EAAkC;AAC9B;AACA;AACAR,qBAASC,SAASM,YAAY,CAA9B;AACH,SAJD,MAIO;AACH;AACA;AACA,gBAAII,OAAOrD,IAAIP,GAAJ,CAAQM,GAAR,CAAX;AACA;AACA;AACAoD,sBAAUtD,KAAKH,SAAL,GAAiBW,OAAjB,CAAyBqC,MAAzB,CAAV;AACAU,sBAAUtD,KAAKJ,SAAL,GAAiBW,OAAjB,CAAyBsC,MAAzB,CAAV;AACA,gBAAIQ,QAAQX,GAAR,CAAYa,IAAZ,IAAoBD,QAAQZ,GAAR,CAAYa,IAAZ,CAApB,GAAwCJ,YAAYA,SAAxD,EAAmE;AAC/D;AACAP,yBAASC,SAASM,YAAY,CAA9B;AACAE,0BAAUC,UAAU,IAApB,CAH+D,CAGrC;AAC7B;AACJ;;AAED;AACA;AACA,eAAO,CAACrD,GAAD,EAAMA,IAAIK,GAAJ,CAAQ+C,WAAWtD,KAAKH,SAAL,GAAiBW,OAAjB,CAAyBqC,MAAzB,CAAnB,CAAN,EACC1C,IAAII,GAAJ,CAAQgD,WAAWtD,KAAKJ,SAAL,GAAiBW,OAAjB,CAAyBsC,MAAzB,CAAnB,CADD,EACuD3C,GADvD,CAAP;AAEH,KAzKQ;;AA2KT;AACA;AACAkB,oBAAgB,wBAASvB,KAAT,EAAgBC,IAAhB,EAAsBkC,CAAtB,EAAyBhB,KAAzB,EAAgC;AAC5C,aAAK,IAAID,IAAIlB,KAAb,EAAoBkB,KAAKjB,IAAzB,EAA+BiB,GAA/B,EAAoC;AAChCiB,cAAEjB,IAAIlB,KAAN,IAAe,KAAK2D,QAAL,CAAcxC,KAAd,EAAqB,KAAK/B,MAAL,CAAY8B,CAAZ,CAArB,EAAqCiB,EAAEjB,IAAIlB,KAAN,CAArC,CAAf;AACH;AACD;AACA;AACA,aAAK,IAAIkB,IAAI,CAAR,EAAWgB,IAAIC,EAAEvC,MAAtB,EAA8BsB,IAAIgB,CAAlC,EAAqChB,GAArC,EAA0C;AACtC,gBAAIiB,EAAEjB,CAAF,KAAQiB,EAAEjB,IAAI,CAAN,CAAZ,EACI,OAAO,KAAP;AACP;AACD,eAAO,IAAP;AACH,KAxLQ;;AA0LT;AACAyC,cAAU,kBAASxC,KAAT,EAAgByC,KAAhB,EAAuBzB,CAAvB,EAA0B;AAChC,YAAI0B,SAAS,EAAb;AAAA,YACIC,SAAS,EADb;AAEA;AACA,aAAK,IAAI5C,IAAI,CAAb,EAAgBA,KAAK,CAArB,EAAwBA,GAAxB,EAA6B;AACzB2C,mBAAO3C,CAAP,IAAYC,MAAMD,IAAI,CAAV,EAAapB,GAAb,CAAiBqB,MAAMD,CAAN,CAAjB,EAA2BU,GAA3B,CAA+B,CAA/B,CAAZ;AACH;AACD;AACA,aAAK,IAAIV,IAAI,CAAb,EAAgBA,KAAK,CAArB,EAAwBA,GAAxB,EAA6B;AACzB4C,mBAAO5C,CAAP,IAAY2C,OAAO3C,IAAI,CAAX,EAAcpB,GAAd,CAAkB+D,OAAO3C,CAAP,CAAlB,EAA6BU,GAA7B,CAAiC,CAAjC,CAAZ;AACH;AACD;AACA,YAAImC,KAAK,KAAKC,QAAL,CAAc,CAAd,EAAiB7C,KAAjB,EAAwBgB,CAAxB,CAAT;AAAA,YACI/B,MAAM,KAAK4D,QAAL,CAAc,CAAd,EAAiBH,MAAjB,EAAyB1B,CAAzB,CADV;AAAA,YAEI9B,MAAM,KAAK2D,QAAL,CAAc,CAAd,EAAiBF,MAAjB,EAAyB3B,CAAzB,CAFV;AAAA,YAGI8B,OAAOF,GAAGjE,GAAH,CAAO8D,KAAP,CAHX;AAAA,YAIIM,KAAK9D,IAAIyC,GAAJ,CAAQzC,GAAR,IAAe6D,KAAKpB,GAAL,CAASxC,GAAT,CAJxB;AAKA;AACA,YAAIS,KAAKmC,GAAL,CAASiB,EAAT,IAAe,MAAMpF,SAAzB,EACI,OAAOqD,CAAP;AACJ;AACA,eAAOA,IAAI8B,KAAKpB,GAAL,CAASzC,GAAT,IAAgB8D,EAA3B;AACH,KAjNQ;;AAmNT;AACAF,cAAU,kBAASG,MAAT,EAAiBhD,KAAjB,EAAwBiB,CAAxB,EAA2B;AACjC;AACA,YAAIQ,MAAMzB,MAAMiD,KAAN,EAAV;AACA;AACA,aAAK,IAAIlD,IAAI,CAAb,EAAgBA,KAAKiD,MAArB,EAA6BjD,GAA7B,EAAkC;AAC9B,iBAAK,IAAImD,IAAI,CAAb,EAAgBA,KAAKF,SAASjD,CAA9B,EAAiCmD,GAAjC,EAAsC;AAClCzB,oBAAIyB,CAAJ,IAASzB,IAAIyB,CAAJ,EAAOzC,GAAP,CAAW,IAAIQ,CAAf,EAAkB3B,GAAlB,CAAsBmC,IAAIyB,IAAI,CAAR,EAAWzC,GAAX,CAAeQ,CAAf,CAAtB,CAAT;AACH;AACJ;AACD,eAAOQ,IAAI,CAAJ,CAAP;AACH,KA9NQ;;AAgOT;AACA;AACAhC,6BAAyB,iCAASZ,KAAT,EAAgBC,IAAhB,EAAsB;AAC3C,YAAIkC,IAAI,CAAC,CAAD,CAAR;AACA,aAAK,IAAIjB,IAAIlB,QAAQ,CAArB,EAAwBkB,KAAKjB,IAA7B,EAAmCiB,GAAnC,EAAwC;AACpCiB,cAAEjB,IAAIlB,KAAN,IAAemC,EAAEjB,IAAIlB,KAAJ,GAAY,CAAd,IACL,KAAKZ,MAAL,CAAY8B,CAAZ,EAAepB,GAAf,CAAmB,KAAKV,MAAL,CAAY8B,IAAI,CAAhB,CAAnB,EAAuCX,GAAvC,EADV;AAEH;AACD,aAAK,IAAIW,IAAI,CAAR,EAAWoD,IAAIrE,OAAOD,KAA3B,EAAkCkB,KAAKoD,CAAvC,EAA0CpD,GAA1C,EAA+C;AAC3CiB,cAAEjB,CAAF,KAAQiB,EAAEmC,CAAF,CAAR;AACH;AACD,eAAOnC,CAAP;AACH,KA5OQ;;AA8OT;AACAd,kBAAc,sBAASrB,KAAT,EAAgBC,IAAhB,EAAsBkB,KAAtB,EAA6BgB,CAA7B,EAAgC;AAC1C,YAAIb,QAAQR,KAAKyD,KAAL,CAAW,CAACtE,OAAOD,KAAP,GAAe,CAAhB,IAAqB,CAAhC,CAAZ;AAAA,YACIwE,UAAU,CADd;AAEA,aAAK,IAAItD,IAAIlB,QAAQ,CAArB,EAAwBkB,IAAIjB,IAA5B,EAAkCiB,GAAlC,EAAuC;AACnC,gBAAIuD,IAAI,KAAKT,QAAL,CAAc,CAAd,EAAiB7C,KAAjB,EAAwBgB,EAAEjB,IAAIlB,KAAN,CAAxB,CAAR;AACA,gBAAI0E,IAAID,EAAE3E,GAAF,CAAM,KAAKV,MAAL,CAAY8B,CAAZ,CAAN,CAAR;AACA,gBAAIZ,OAAOoE,EAAE7C,CAAF,GAAM6C,EAAE7C,CAAR,GAAY6C,EAAE5C,CAAF,GAAM4C,EAAE5C,CAA/B,CAHmC,CAGD;AAClC,gBAAIxB,QAAQkE,OAAZ,EAAqB;AACjBA,0BAAUlE,IAAV;AACAgB,wBAAQJ,CAAR;AACH;AACJ;AACD,eAAO;AACHhC,mBAAOsF,OADJ;AAEHlD,mBAAOA;AAFJ,SAAP;AAIH;AA/PQ,CAAb;;AAkQAqD,OAAOC,OAAP,GAAiB;AACbC,cAAU,oBAAY;AAClB,aAAKxF,SAAL,GAAiBN,OAAOC,GAAP,CAAW,IAAX,CAAjB;AACH;AAHY,CAAjB","file":"R.simplify.js","sourceRoot":"..\\..\\..\\..\\..\\..\\assets\\raphael\\component\\optional","sourcesContent":["var EPSILON = 1e-12;\r\nvar TOLERANCE = 1e-6;\r\n\r\nvar Fitter = {\r\n    fit: function (path, error) {\r\n        this.commands = [];\r\n        this.error = error || 10;\r\n\r\n        var points = this.points = [];\r\n        path._commands.forEach( function (cmd) {\r\n            var c = cmd[0];\r\n\r\n            if (c === 'M') {\r\n                points.push( cc.p(cmd[1], cmd[2]) );\r\n            }\r\n            else if(c === 'C') {\r\n                points.push( cc.p(cmd[5], cmd[6]) );\r\n            }\r\n        });\r\n\r\n\r\n        var length = points.length;\r\n\r\n        if (length > 1) {\r\n            this.fitCubic(0, length - 1,\r\n                // Left Tangent\r\n                points[1].sub(points[0]).normalize(),\r\n                // Right Tangent\r\n                points[length - 2].sub(points[length - 1]).normalize());\r\n        }\r\n\r\n        return this.commands;\r\n    },\r\n\r\n    // Fit a Bezier curve to a (sub)set of digitized points\r\n    fitCubic: function (first, last, tan1, tan2) {\r\n        //  Use heuristic if region only has two points in it\r\n        if (last - first === 1) {\r\n            var pt1 = this.points[first],\r\n                pt2 = this.points[last],\r\n                dist = pt1.sub(pt2).mag() / 3;\r\n            this.addCurve([pt1, pt1.add(tan1.normalize().mulSelf(dist)),\r\n                    pt2.add(tan2.normalize().mulSelf(dist)), pt2]);\r\n            return;\r\n        }\r\n        // Parameterize points, and attempt to fit curve\r\n        var uPrime = this.chordLengthParameterize(first, last),\r\n            maxError = Math.max(this.error, this.error * this.error),\r\n            split,\r\n            parametersInOrder = true;\r\n        // Try 4 iterations\r\n        for (var i = 0; i <= 4; i++) {\r\n            var curve = this.generateBezier(first, last, uPrime, tan1, tan2);\r\n            //  Find max deviation of points to fitted curve\r\n            var max = this.findMaxError(first, last, curve, uPrime);\r\n            if (max.error < this.error && parametersInOrder) {\r\n                this.addCurve(curve);\r\n                return;\r\n            }\r\n            split = max.index;\r\n            // If error not too large, try reparameterization and iteration\r\n            if (max.error >= maxError)\r\n                break;\r\n            parametersInOrder = this.reparameterize(first, last, uPrime, curve);\r\n            maxError = max.error;\r\n        }\r\n        // Fitting failed -- split at max error point and fit recursively\r\n        var V1 = this.points[split - 1].sub(this.points[split]),\r\n            V2 = this.points[split].sub(this.points[split + 1]),\r\n            tanCenter = V1.add(V2).div(2).normalize();\r\n        this.fitCubic(first, split, tan1, tanCenter);\r\n        this.fitCubic(split, last, tanCenter.mul(-1), tan2);\r\n    },\r\n\r\n    addCurve: function(curve) {\r\n        if (this.commands.length === 0) {\r\n            this.commands.push(['M', curve[0].x, curve[0].y]);\r\n        }\r\n        else {\r\n            var cmd = this.commands[this.commands.length - 1];\r\n            cmd[5] = curve[0].x;\r\n            cmd[6] = curve[0].y;\r\n        }\r\n\r\n        this.commands.push(['C', curve[1].x, curve[1].y, curve[2].x, curve[2].y, curve[3].x, curve[3].y]);\r\n    },\r\n\r\n    // Use least-squares method to find Bezier control points for region.\r\n    generateBezier: function(first, last, uPrime, tan1, tan2) {\r\n        var epsilon = /*#=*/EPSILON,\r\n            pt1 = this.points[first],\r\n            pt2 = this.points[last],\r\n            // Create the C and X matrices\r\n            C = [[0, 0], [0, 0]],\r\n            X = [0, 0];\r\n\r\n        for (var i = 0, l = last - first + 1; i < l; i++) {\r\n            var u = uPrime[i],\r\n                t = 1 - u,\r\n                b = 3 * u * t,\r\n                b0 = t * t * t,\r\n                b1 = b * t,\r\n                b2 = b * u,\r\n                b3 = u * u * u,\r\n                a1 = tan1.normalize().mulSelf(b1),\r\n                a2 = tan2.normalize().mulSelf(b2),\r\n                tmp = this.points[first + i]\r\n                    .sub(pt1.mul(b0 + b1))\r\n                    .sub(pt2.mul(b2 + b3));\r\n            C[0][0] += a1.dot(a1);\r\n            C[0][1] += a1.dot(a2);\r\n            // C[1][0] += a1.dot(a2);\r\n            C[1][0] = C[0][1];\r\n            C[1][1] += a2.dot(a2);\r\n            X[0] += a1.dot(tmp);\r\n            X[1] += a2.dot(tmp);\r\n        }\r\n\r\n        // Compute the determinants of C and X\r\n        var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\r\n            alpha1, alpha2;\r\n        if (Math.abs(detC0C1) > epsilon) {\r\n            // Kramer's rule\r\n            var detC0X  = C[0][0] * X[1]    - C[1][0] * X[0],\r\n                detXC1  = X[0]    * C[1][1] - X[1]    * C[0][1];\r\n            // Derive alpha values\r\n            alpha1 = detXC1 / detC0C1;\r\n            alpha2 = detC0X / detC0C1;\r\n        } else {\r\n            // Matrix is under-determined, try assuming alpha1 == alpha2\r\n            var c0 = C[0][0] + C[0][1],\r\n                c1 = C[1][0] + C[1][1];\r\n            if (Math.abs(c0) > epsilon) {\r\n                alpha1 = alpha2 = X[0] / c0;\r\n            } else if (Math.abs(c1) > epsilon) {\r\n                alpha1 = alpha2 = X[1] / c1;\r\n            } else {\r\n                // Handle below\r\n                alpha1 = alpha2 = 0;\r\n            }\r\n        }\r\n\r\n        // If alpha negative, use the Wu/Barsky heuristic (see text)\r\n        // (if alpha is 0, you get coincident control points that lead to\r\n        // divide by zero in any subsequent NewtonRaphsonRootFind() call.\r\n        var segLength = pt2.sub(pt1).mag(),\r\n            eps = epsilon * segLength,\r\n            handle1,\r\n            handle2;\r\n        if (alpha1 < eps || alpha2 < eps) {\r\n            // fall back on standard (probably inaccurate) formula,\r\n            // and subdivide further if needed.\r\n            alpha1 = alpha2 = segLength / 3;\r\n        } else {\r\n            // Check if the found control points are in the right order when\r\n            // projected onto the line through pt1 and pt2.\r\n            var line = pt2.sub(pt1);\r\n            // Control points 1 and 2 are positioned an alpha distance out\r\n            // on the tangent vectors, left and right, respectively\r\n            handle1 = tan1.normalize().mulSelf(alpha1);\r\n            handle2 = tan2.normalize().mulSelf(alpha2);\r\n            if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\r\n                // Fall back to the Wu/Barsky heuristic above.\r\n                alpha1 = alpha2 = segLength / 3;\r\n                handle1 = handle2 = null; // Force recalculation\r\n            }\r\n        }\r\n\r\n        // First and last control points of the Bezier curve are\r\n        // positioned exactly at the first and last data points\r\n        return [pt1, pt1.add(handle1 || tan1.normalize().mulSelf(alpha1)),\r\n                pt2.add(handle2 || tan2.normalize().mulSelf(alpha2)), pt2];\r\n    },\r\n\r\n    // Given set of points and their parameterization, try to find\r\n    // a better parameterization.\r\n    reparameterize: function(first, last, u, curve) {\r\n        for (var i = first; i <= last; i++) {\r\n            u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\r\n        }\r\n        // Detect if the new parameterization has reordered the points.\r\n        // In that case, we would fit the points of the path in the wrong order.\r\n        for (var i = 1, l = u.length; i < l; i++) {\r\n            if (u[i] <= u[i - 1])\r\n                return false;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    // Use Newton-Raphson iteration to find better root.\r\n    findRoot: function(curve, point, u) {\r\n        var curve1 = [],\r\n            curve2 = [];\r\n        // Generate control vertices for Q'\r\n        for (var i = 0; i <= 2; i++) {\r\n            curve1[i] = curve[i + 1].sub(curve[i]).mul(3);\r\n        }\r\n        // Generate control vertices for Q''\r\n        for (var i = 0; i <= 1; i++) {\r\n            curve2[i] = curve1[i + 1].sub(curve1[i]).mul(2);\r\n        }\r\n        // Compute Q(u), Q'(u) and Q''(u)\r\n        var pt = this.evaluate(3, curve, u),\r\n            pt1 = this.evaluate(2, curve1, u),\r\n            pt2 = this.evaluate(1, curve2, u),\r\n            diff = pt.sub(point),\r\n            df = pt1.dot(pt1) + diff.dot(pt2);\r\n        // Compute f(u) / f'(u)\r\n        if (Math.abs(df) < /*#=*/TOLERANCE)\r\n            return u;\r\n        // u = u - f(u) / f'(u)\r\n        return u - diff.dot(pt1) / df;\r\n    },\r\n\r\n    // Evaluate a bezier curve at a particular parameter value\r\n    evaluate: function(degree, curve, t) {\r\n        // Copy array\r\n        var tmp = curve.slice();\r\n        // Triangle computation\r\n        for (var i = 1; i <= degree; i++) {\r\n            for (var j = 0; j <= degree - i; j++) {\r\n                tmp[j] = tmp[j].mul(1 - t).add(tmp[j + 1].mul(t));\r\n            }\r\n        }\r\n        return tmp[0];\r\n    },\r\n\r\n    // Assign parameter values to digitized points\r\n    // using relative distances between points.\r\n    chordLengthParameterize: function(first, last) {\r\n        var u = [0];\r\n        for (var i = first + 1; i <= last; i++) {\r\n            u[i - first] = u[i - first - 1]\r\n                    + this.points[i].sub(this.points[i - 1]).mag();\r\n        }\r\n        for (var i = 1, m = last - first; i <= m; i++) {\r\n            u[i] /= u[m];\r\n        }\r\n        return u;\r\n    },\r\n\r\n    // Find the maximum squared distance of digitized points to fitted curve.\r\n    findMaxError: function(first, last, curve, u) {\r\n        var index = Math.floor((last - first + 1) / 2),\r\n            maxDist = 0;\r\n        for (var i = first + 1; i < last; i++) {\r\n            var P = this.evaluate(3, curve, u[i - first]);\r\n            var v = P.sub(this.points[i]);\r\n            var dist = v.x * v.x + v.y * v.y; // squared\r\n            if (dist >= maxDist) {\r\n                maxDist = dist;\r\n                index = i;\r\n            }\r\n        }\r\n        return {\r\n            error: maxDist,\r\n            index: index\r\n        };\r\n    }\r\n};\r\n\r\nmodule.exports = {\r\n    simplify: function () {\r\n        this._commands = Fitter.fit(this);\r\n    }\r\n};\r\n"]}